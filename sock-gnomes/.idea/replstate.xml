<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1461602405996">{:repl-history {:ide [], :local [&quot;@dryer&quot; &quot;(:name @dryer)&quot; &quot;@sock-gnome&quot; &quot;(map #(%) sock-varieties)&quot; &quot;(map #(println %) sock-varieties)&quot; &quot;(map #(sock-count % 2) sock-varieties)&quot; &quot;(set (map #(sock-count % 2) sock-varieties))&quot; &quot;(vector (map #(sock-count % 2) sock-varieties))&quot; &quot;(doc hash-map)&quot; &quot;(doc map)&quot; &quot;(doc dosync)&quot; &quot;(steal-sock sock-gnome dryer)&quot; &quot;(:socks @dryer)&quot; &quot;(:socks @sock-gnome)&quot; &quot;(similar-socks (first (:socks @sock-gnome)) (:socks @dryer))&quot; &quot;(doc future)&quot; &quot;(def ^:dynamic *troll-thought* nil)&quot; &quot;(defn troll-riddle\n  [your-answer]\n  (let [number \&quot;man meat\&quot;]\n    (when (thread-bound? #'*troll-thought*)\n      (set! *troll-thought* number))\n    (if (= number your-answer)\n      \&quot;TROLL: You can cross the bridge!\&quot;\n      \&quot;TROLL: Time to eat you, succulent human!\&quot;)))&quot; &quot;(binding [*troll-thought* nil]\n  (println (troll-riddle 2))\n  (println \&quot;SUCCULENT HUMAN: Oooooh!  The answer was\&quot; *troll-thought*))&quot; &quot;(binding [*troll-thought* nil]\n  (println (troll-riddle \&quot;man meat\&quot;))\n  (println \&quot;SUCCULENT HUMAN: Oooooh!  The answer was\&quot; *troll-thought*))&quot; &quot;(doc thread-bound?)&quot; &quot;(doc bound?)&quot; &quot;(.write *out* \&quot;prints to REPL\&quot;)&quot; &quot;(.start (Thread. #(.write *out* \&quot;prints to standard out\&quot;)))&quot; &quot;(let [out *out*]\n  (.start\n    (Thread. #(binding [*out* out]\n               (.write *out* \&quot;prints to REPL from thread\&quot;)))))&quot; &quot;(.start (Thread. (bound-fn [] (.write *out* \&quot;prints to REPL from thread\&quot;))))&quot; &quot;(defn always-1\n  []\n  1)&quot; &quot;(take 5 (repeatedly always-1))&quot; &quot;(take 5 (repeatedly (partial rand-int 10)))&quot; &quot;(def alphabet-length 26)&quot; &quot;(def letters (mapv (comp str char (partial + 65)) (range alphabet-length)))&quot; &quot;(defn random-string\n  \&quot;Returns a random string of specified length\&quot;\n  [length]\n  (apply str (take length (repeatedly #(rand-nth letters)))))&quot; &quot;(defn random-string-list\n  [list-length string-length]\n  (doall (take list-length (repeatedly (partial random-string string-length)))))&quot; &quot;(def orc-names (random-string-list 3000 7000))&quot; &quot;(time (dorun (map clojure.string/lower-case orc-names)))&quot; &quot;(time (dorun (pmap clojure.string/lower-case orc-names)))&quot; &quot;(def orc-name-abbrevs (random-string-list 20000 300))&quot; &quot;(time (dorun (map clojure.string/lower-case orc-name-abbrevs)))&quot; &quot;(time (dorun (pmap clojure.string/lower-case orc-name-abbrevs)))&quot; &quot;(def numbers [1 2 3 4 5 6 7 8 9 10])&quot; &quot;(partition-all 3 numbers)&quot; &quot;(pmap inc numbers)&quot; &quot;(pmap (fn [number-group] (doall (map inc number-group)))\n      (partition-all 3 numbers))&quot; &quot;(time (pmap (fn [number-group] (doall (map inc number-group)))\n      (partition-all 3 numbers)))&quot; &quot;(time (pmap inc numbers))&quot; &quot;(doc doall)&quot; &quot;(defn ppmap\n  \&quot;Partitioned pmap, for grouping map ops together to make parallel overhead worthwhile\&quot;\n  [grain-size f &amp; colls]\n  (apply concat\n         (apply pmap\n                (fn [&amp; pgroups] (doall (apply map f pgroups)))\n                (map (partial partition-all grain-size) colls))))&quot; &quot;(time (dorun (ppmap 1000 clojure.string/lower-case orc-name-abbrevs)))&quot; &quot;(doc alts!!)&quot; &quot;(set '(:a :a :b :c :c :c :c :d :d))&quot; &quot;(= #{:a :b :c :d} (set '(:a :a :b :c :c :c :c :d :d)))&quot; &quot;(conj #{1 4 3} #{2})&quot;], :remote []}}</component>
</project>